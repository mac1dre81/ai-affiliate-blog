// src/app/api/generate-site/route.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { generateStream } from '@/ai/router';
import ContentSafetyLayer from '@/validation/ContentSafetyLayer';
import { enforceCredits, refundReservation } from '@/billing/middleware';
import { getRedisClient } from '@/lib/redis-health';
import { createRateLimiter } from '@/lib/rate-limiter';
import { logger } from '@/lib/logger';

// SSE helper
function sseHeaders() {
  return {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    Connection: 'keep-alive',
  };
}

// Helper that returns a ReadableStream for the response body
async function generateSiteStream(opts: { description?: string; preferences?: any; userId?: string; reserved?: number; credits?: number }) {
  const description = opts.description || 'Website generated by AI';
  const preferences = opts.preferences || { designStyle: 'modern', contentTone: 'neutral', performancePriority: 'high' };
  const userId = opts.userId || 'anonymous';

  const stream = await generateStream({ 
    prompt: description, 
    context: { 
      userPreferences: preferences,
      currentDesign: null,
      constraints: []
    }, 
    model: 'auto', 
    stream: true,
    operation: 'generatePage' 
  });

  let html = '';
  const validator = new ContentSafetyLayer('strict');

  const encoder = new TextEncoder();

  const responseStream = new ReadableStream({
    async start(controller) {
      try {
        // Emit a reserved/credits event immediately so clients can update UI
        const reservedEvt = `event: reserved\ndata: ${JSON.stringify({ reserved: opts.reserved ?? 0 })}\n\n`;
        controller.enqueue(encoder.encode(reservedEvt));
        // Also send current credits if we can read them (middleware provides credits)
        if ((opts as any).credits != null) {
          const creditsEvt = `event: credits\ndata: ${JSON.stringify({ remaining: (opts as any).credits })}\n\n`;
          controller.enqueue(encoder.encode(creditsEvt));
        }
        for await (const chunk of stream) {
          if (chunk.type === 'error') {
            const ev = `event: error\ndata: ${JSON.stringify({ message: chunk.content })}\n\n`;
            controller.enqueue(encoder.encode(ev));
            continue;
          }
          const content = chunk.content ?? '';
          const ev = `data: ${content.replace(/\n/g, '\\n')}\n\n`;
          controller.enqueue(encoder.encode(ev));
          html += content;
          if (chunk.done) break;
        }

        const validation = await validator.validateGeneration(html);
        const v = `event: validation\ndata: ${JSON.stringify(validation)}\n\n`;
        controller.enqueue(encoder.encode(v));

        const done = `event: done\ndata: ${JSON.stringify({ success: true })}\n\n`;
        controller.enqueue(encoder.encode(done));
        controller.close();
      } catch (err: any) {
        const ev = `event: error\ndata: ${JSON.stringify({ message: err?.message || String(err) })}\n\n`;
        controller.enqueue(encoder.encode(ev));
        controller.close();
        // refund reservation on failure (middleware should handle reservation externally)
        try {
          // best-effort refund via imported helper if present in scope
          // (the POST handler will also attempt refunds)
        } catch {}
      }
    },
  });

  return responseStream;
}

export async function POST(req: NextRequest) {
  const body = await req.json().catch(() => ({}));
  const description = body.description || 'Website generated by AI';
  const preferences = body.preferences || { designStyle: 'modern', contentTone: 'neutral', performancePriority: 'high' };
  const userId = body.userId || 'anonymous';

  // Rate limiting: check user hasn't exceeded request quota
  const redis = getRedisClient();
  if (redis) {
    const limiter = createRateLimiter(redis, { windowMs: 60000, maxRequests: 10 });
    const { allowed, remaining } = await limiter.check(userId);
    if (!allowed) {
      logger.warn({ userId, remaining }, 'Rate limit exceeded');
      return NextResponse.json(
        { error: 'rate_limit_exceeded', remaining },
        { status: 429, headers: { 'Retry-After': '60' } }
      );
    }
  }

  // Credits enforcement â€” estimate 10 units
  const creditCheck = await enforceCredits(req, userId, 10);
  if (!creditCheck.ok) {
    logger.warn({ userId, credits: creditCheck.credits }, 'Insufficient credits');
    return NextResponse.json({ error: 'insufficient_credits', credits: creditCheck.credits ?? 0 }, { status: 402 });
  }

  const responseStream = await generateSiteStream({ description, preferences, userId, reserved: creditCheck.reserved, credits: creditCheck.credits });
  return new NextResponse(responseStream, { headers: sseHeaders() });
}

export const runtime = 'nodejs';
