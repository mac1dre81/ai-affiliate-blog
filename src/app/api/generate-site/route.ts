// src/app/api/generate-site/route.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { generateStream } from '@/ai/router';
import ContentSafetyLayer from '@/validation/ContentSafetyLayer';
import { enforceCredits, refundReservation } from '@/billing/middleware';

// SSE helper
function sseHeaders() {
  return {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    Connection: 'keep-alive',
  };
}

// exported helper that returns a ReadableStream for testing and reuse
export async function generateSiteStream(opts: { description?: string; preferences?: any; userId?: string }) {
  const description = opts.description || 'Website generated by AI';
  const preferences = opts.preferences || { designStyle: 'modern', contentTone: 'neutral', performancePriority: 'high' };
  const userId = opts.userId || 'anonymous';

  const stream = await generateStream({ prompt: description, context: { userPreferences: preferences }, model: 'auto', stream: true, operation: 'generatePage' });

  let html = '';
  const validator = new ContentSafetyLayer('strict');

  const encoder = new TextEncoder();

  const responseStream = new ReadableStream({
    async start(controller) {
      try {
        for await (const chunk of stream) {
          if (chunk.type === 'error') {
            const ev = `event: error\ndata: ${JSON.stringify({ message: chunk.content })}\n\n`;
            controller.enqueue(encoder.encode(ev));
            continue;
          }
          const content = chunk.content ?? '';
          const ev = `data: ${content.replace(/\n/g, '\\n')}\n\n`;
          controller.enqueue(encoder.encode(ev));
          html += content;
          if (chunk.done) break;
        }

        const validation = await validator.validateGeneration(html);
        const v = `event: validation\ndata: ${JSON.stringify(validation)}\n\n`;
        controller.enqueue(encoder.encode(v));

        const done = `event: done\ndata: ${JSON.stringify({ success: true })}\n\n`;
        controller.enqueue(encoder.encode(done));
        controller.close();
      } catch (err: any) {
        const ev = `event: error\ndata: ${JSON.stringify({ message: err?.message || String(err) })}\n\n`;
        controller.enqueue(encoder.encode(ev));
        controller.close();
        // refund reservation on failure (middleware should handle reservation externally)
      }
    },
  });

  return responseStream;
}

export async function POST(req: NextRequest) {
  const body = await req.json().catch(() => ({}));
  const description = body.description || 'Website generated by AI';
  const preferences = body.preferences || { designStyle: 'modern', contentTone: 'neutral', performancePriority: 'high' };
  const userId = body.userId || 'anonymous';

  // Simple credits enforcement â€” estimate 10 units
  const creditCheck = await enforceCredits(req, userId, 10);
  if (!creditCheck.ok) {
    return NextResponse.json({ error: 'insufficient_credits', credits: creditCheck.credits ?? 0 }, { status: 402 });
  }

  const responseStream = await generateSiteStream({ description, preferences, userId });
  return new NextResponse(responseStream, { headers: sseHeaders() });
}

export const runtime = 'edge';

export default POST;
