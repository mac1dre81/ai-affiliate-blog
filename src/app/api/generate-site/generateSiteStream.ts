import { generateStream } from '@/ai/router';
import ContentSafetyLayer from '@/validation/ContentSafetyLayer';

export async function generateSiteStream(opts: { description?: string; preferences?: any; userId?: string; reserved?: number; credits?: number }) {
  const description = opts.description || 'Website generated by AI';
  const preferences = opts.preferences || { designStyle: 'modern', contentTone: 'neutral', performancePriority: 'high' };
  const userId = opts.userId || 'anonymous';

  const stream = await generateStream({ 
    prompt: description, 
    context: { 
      userPreferences: preferences,
      currentDesign: null,
      constraints: []
    }, 
    model: 'auto', 
    stream: true,
    operation: 'generatePage' 
  });

  let html = '';
  const validator = new ContentSafetyLayer('strict');

  const encoder = new TextEncoder();

  const responseStream = new ReadableStream({
    async start(controller) {
      try {
        // Emit a reserved/credits event immediately so clients can update UI
        const reservedEvt = `event: reserved\ndata: ${JSON.stringify({ reserved: opts.reserved ?? 0 })}\n\n`;
        controller.enqueue(encoder.encode(reservedEvt));
        // Also send current credits if we can read them (middleware provides credits)
        if ((opts as any).credits != null) {
          const creditsEvt = `event: credits\ndata: ${JSON.stringify({ remaining: (opts as any).credits })}\n\n`;
          controller.enqueue(encoder.encode(creditsEvt));
        }
        for await (const chunk of stream) {
          if (chunk.type === 'error') {
            const ev = `event: error\ndata: ${JSON.stringify({ message: chunk.content })}\n\n`;
            controller.enqueue(encoder.encode(ev));
            continue;
          }
          const content = chunk.content ?? '';
          const ev = `data: ${content.replace(/\n/g, '\\n')}\n\n`;
          controller.enqueue(encoder.encode(ev));
          html += content;
          if (chunk.done) break;
        }

        const validation = await validator.validateGeneration(html);
        const v = `event: validation\ndata: ${JSON.stringify(validation)}\n\n`;
        controller.enqueue(encoder.encode(v));

        const done = `event: done\ndata: ${JSON.stringify({ success: true })}\n\n`;
        controller.enqueue(encoder.encode(done));
        controller.close();
      } catch (err: any) {
        const ev = `event: error\ndata: ${JSON.stringify({ message: err?.message || String(err) })}\n\n`;
        controller.enqueue(encoder.encode(ev));
        controller.close();
        // refund reservation on failure (middleware should handle reservation externally)
        try {
          // best-effort refund via imported helper if present in scope
          // (the POST handler will also attempt refunds)
        } catch {}
      }
    },
  });

  return responseStream;
}
